#!/usr/bin/env python3

import rospy
import homework2.Figure8 as f8
from geometry_msgs.msg import Twist, Vector3, PoseStamped, Pose, Point, Quaternion
#from std_msgs.msg import Float64
from nav_msgs.msg import Path
#from tf.msg import tfMessage
#from tf.transformations import quaternion_from_euler


class Trajectory:
    '''
    Publishes:  geometry_msgs/Twist message to cmd_vel
                nav_msgs/Path message to rviz?
    Broadcasts: static transform from world to odom 
    Services:   pause - stop turtle motion
                resume - resume turtle motion
    Parameters: width of figure 8
                height of figure 8
                period
                ~pub_freq
    '''

    def __init__(self):
        '''
        constructor
        '''
        
        #import parameters
        self.W = rospy.get_param("/width")
        self.H = rospy.get_param("/height")
        self.T = rospy.get_param("/period")
        
        #initialize publishers
        self.pub = rospy.Publisher('cmd_vel',Twist,queue_size=10) 
        self.ppub = rospy.Publisher('/path',Path,queue_size=10,latch=True)
        self.pub_freq = 200
        self.prate = rospy.Rate(self.pub_freq)


def turtle_twist(xdot,omega):
    '''
    converts velocity and angular velocity to geometry_msgs/Twist message
    args:       xdot - velocity
                omega - angular velocity
    reuturns:   Twist message
    '''
    return Twist(linear = Vector3(x = xdot, y = 0, z = 0),
                angular = Vector3(x = 0, y = 0, z = omega))

def convert_to_path(x,y,th):
    '''
    converts positional and angular arguments to path message while publishing to path topic
    Args:
        x (float list): x positions
        y (float list): y positions
        th (float list): yaws
    Returns:
        path (nav_msgs/Path): turtle trajectory
    '''
    path = Path()
    path.poses = []
    path.header.frame_id = 'map'
    path.header.stamp = rospy.Time.now()
    for i in range(0,len(x)):
        #q = quaternion_from_euler(0,0,th[i])
        q = Quaternion(0,0,0,1)
        pt = Point(x[i],y[i],1)
        po = Pose(pt,q)
        post = PoseStamped()
        post.pose = po
        path.poses.append(post)

    return path


def main():
    '''
    main function to calculate and execute figure eight trajectory
    '''
    #initialize node & class
    rospy.init_node('trajectory')                               
    tr = Trajectory()

    #initialize figure8 class with imported parameters
    calc = f8.figure8([tr.W,tr.H,tr.T,tr.pub_freq])

    #calculate trajectory
    th0 = calc.find_th0()
    vd = calc.find_vlist()
    wd = calc.find_wlist()
    thlist = calc.find_thlist()
    xlist = calc.find_xlist()
    ylist = calc.find_ylist()

    #publish Path message to /path
    path = convert_to_path(xlist,ylist,thlist)
    tr.ppub.publish(path)

    #Orient turtle
    now = rospy.get_time()
    while rospy.get_time() < now+4:
        tr.pub.publish(turtle_twist(0,th0/4))
        tr.prate.sleep()
    tr.pub.publish(turtle_twist(0,0))

    #FIGURE 8
    i = 0
    now = rospy.get_time()
    while rospy.get_time() < now+tr.T:
        tr.pub.publish(turtle_twist(vd[i],wd[i]))
        i=i+1
        tr.prate.sleep()

    tr.pub.publish(turtle_twist(0,0))

    
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except:
        rospy.ROSInterruptException